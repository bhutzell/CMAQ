
C:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      Module aero6_ddm3d

C-----------------------------------------------------------------------
C   15 Aug 13 S.L.Napelenok: initial version
C-----------------------------------------------------------------------

      Use ddm3d_defn, Only : npmax

      Implicit None

      Integer, Parameter          :: nbdirsmax = 20   ! maximum number of sensitivity this can handle

c These parameters have to match what is found in the following modules:
c aero_data, precursor_data, soa_defn:
      Integer, Private, Parameter :: n_aerospc = 40   ! number of aero species
      Integer, Private, Parameter :: n_mode = 3       ! number of modes:
      Integer, Private, Parameter :: n_precursor = 19 ! # of precursors
      Integer, Private, Parameter :: n_vapor = 12     ! # of partitioning SVOCs
      Integer, Private, Parameter :: n_orgprod = 10   ! # of ROG rxn counter species

      Real( 8 ), Allocatable, Save :: s_aerospc_conc( :,:,: )  ! aero species sensitivity [ ug/m^3 ]

      Real( 8 ), Allocatable, Save :: s_precursor_conc( :,: )  ! precursor sensitivity [ug/m^3]
      Real( 8 ), Allocatable, Save :: s_so4rate( : )

      Real( 8 ), Allocatable, Save :: s_vapor_conc( :,: )      ! vapor sensitivity
      Real( 8 ), Allocatable, Save :: s_orgprod_conc( :,: )    ! orgprod sensitivity

      Logical, Save :: ae_ddm3d_ready = .False.


      Contains
C-----------------------------------------------------------------------
      
      Subroutine init_aero6_ddm3d

      Use UTILIO_DEFN

      Implicit None

      Character( 96 ) :: xmsg = ''
      Integer allocstat
      Integer logdev

      logdev = init3()

      Allocate ( s_aerospc_conc( n_aerospc,n_mode,npmax ), stat = allocstat )
      If ( allocstat .Ne. 0 ) then
         xmsg = 'Failure allocating s_aerospc_conc'
         Call m3exit ( 'init_aero6_ddm3d', 0, 0, xmsg, xstat2 )
      End If

      Allocate ( s_precursor_conc( n_precursor,npmax ), stat = allocstat )
      If ( allocstat .Ne. 0 ) then
         xmsg = 'Failure allocating s_precursor_conc'
         Call m3exit ( 'init_aero6_ddm3d', 0, 0, xmsg, xstat2 )
      End If

      Allocate ( s_so4rate( npmax ), stat = allocstat )
      If ( allocstat .Ne. 0 ) then
         xmsg = 'Failure allocating s_so4rate'
         Call m3exit ( 'init_aero6_ddm3d', 0, 0, xmsg, xstat2 )
      End If

      Allocate ( s_vapor_conc( n_vapor,npmax ), stat = allocstat )
      If ( allocstat .Ne. 0 ) then
         xmsg = 'Failure allocating s_vapor_conc'
         Call m3exit ( 'init_aero6_ddm3d', 0, 0, xmsg, xstat2 )
      End If

      Allocate ( s_orgprod_conc( n_orgprod,npmax ), stat = allocstat )
      If ( allocstat .Ne. 0 ) then
         xmsg = 'Failure allocating s_orgprod_conc'
         Call m3exit ( 'init_aero6_ddm3d', 0, 0, xmsg, xstat2 )
      End If

      ae_ddm3d_ready = .True.

      Return
      End Subroutine init_aero6_ddm3d

C-----------------------------------------------------------------------

      SUBROUTINE NEWT_DV(layer, x, xd, n, check, ctot, ctotd, csat,
     +                   imwcv, minitw, minitwd, nbdirs)

C        Generated by TAPENADE     (INRIA, Tropics team)
C  Tapenade 3.7 (r4888) - 28 May 2013 10:47
C
C  Differentiation of newt in forward (tangent) mode:
C   variations   of useful results: x
C   with respect to varying inputs: x ctot minitw
C   RW status of diff variables: x:in-out ctot:in minitw:in

C  Arguments
C
C model layer
      INTEGER layer
C dimension of problem
      INTEGER n
C initial guess of CAER
      REAL( 4 ) x(n)
      REAL( 8 ) xd(nbdirsmax, n)
      LOGICAL check
C total concentration GAS + AER + PROD
      REAL( 4 ) ctot(n)
      REAL( 8 ) ctotd(nbdirsmax, n)
C saturation conc. of cond. vapor [ug/m^3]
      REAL( 4 ) csat(n)
C inverse molecular weights
      REAL( 4 ) imwcv(n)
C weighted initial mass
      REAL( 4 ) minitw
      REAL( 8 ) minitwd(nbdirsmax)
C
C  Following Numerical recipes
C
      INTEGER nn
C vector of functions to be zeroed
      REAL( 8 ) fvec
      COMMON /newtv/ fvec(n_vapor), nn
      SAVE /newtv/
C
C  Parameters
C maximum number of iterations
      INTEGER, PARAMETER :: maxits=100
C convergence criterion on fxn values
      REAL( 8 ), PARAMETER :: tolf=1.0e-09
C criterion whether spurious conver-
C gence to a minimum has occurred
      REAL( 8 ), PARAMETER :: tolmin=1.0e-12
C convergence criterion on delta_x
      REAL( 8 ), PARAMETER :: tolx=1.0e-10
C scaled maximum step length allowed
      REAL( 8 ), PARAMETER :: stpmx=100.0
C
C  Local variables
      REAL( 8 ) ct
      REAL( 8 ) cs
      REAL( 8 ) imw
      REAL( 8 ) m
      REAL( 8 ) md(nbdirsmax)
      COMMON /newtinp/ ct(n_vapor), cs(n_vapor), imw(n_vapor), m
      SAVE /newtinp/
C
      INTEGER i, its, j, indx(n_vapor)
      REAL( 8 ) d, den, f, fold, stpmax, sum, temp, test
      REAL( 8 ) fd(nbdirsmax), foldd(nbdirsmax), stpmaxd(nbdirsmax), sumd(
     +     nbdirsmax)
      REAL( 8 ) fjac(n_vapor, n_vapor)
      REAL( 8 ) g(n_vapor), p(n_vapor), xold(n_vapor)
      INTEGER nd
      INTEGER nbdirs
      REAL( 8 ) gd(nbdirsmax, n_vapor)
      INTRINSIC MAX
      REAL( 8 ) fjacd(nbdirsmax, n_vapor, n_vapor)
      REAL( 8 ) pd(nbdirsmax, n_vapor)
      REAL( 8 ) x3
      INTRINSIC ABS
      REAL( 8 ) x2
      REAL*8 x1
      INTRINSIC FLOAT
      REAL*8 max1d(nbdirsmax)
      REAL*8 x1d(nbdirsmax)
      REAL( 8 ) abs3
      REAL( 8 ) abs2
      REAL( 8 ) abs1
      REAL( 8 ) abs0
      INTEGER ii2
      REAL( 8 ) xoldd(nbdirsmax, n_vapor)
      INTEGER ii1
      INTRINSIC SQRT
      REAL( 8 ) max3
      REAL( 8 ) max2
      REAL*8 max1
      REAL*8 y1
      COMMON /newtinp_dv/ md
C     EXTERNAL FDJAC
C
C-----------------------------------------------------------------------
C
      check = .false.
      DO nd=1,nbdirs
        md(nd) = minitwd(nd)
      ENDDO
      m = minitw
      DO i=1,n
        ct(i) = ctot(i)
        cs(i) = csat(i)
        imw(i) = imwcv(i)
      ENDDO
C
      nn = n
      CALL FMINV_DV(x, xd, f, fd, nbdirs)
C The vector FVEC is also computed by this call
C Test for initial guess being a root. Use more
C stringent test than simply TOLF.
      test = 0.0
      DO i=1,n
        IF (fvec(i) .GE. 0.) THEN
          abs0 = fvec(i)
        ELSE
          abs0 = -fvec(i)
        END IF
        IF (abs0 .GT. test) THEN
          IF (fvec(i) .GE. 0.) THEN
            test = fvec(i)
          ELSE
            test = -fvec(i)
          END IF
        END IF
      ENDDO
C
C initial guess is a root
      IF (test .LT. 0.01*tolf) THEN
        RETURN
      ELSE
C Calculate STPMAX for line searches
        sum = 0.0
        DO nd=1,nbdirs
          sumd(nd) = 0.0
        ENDDO
        DO i=1,n
          DO nd=1,nbdirs
            sumd(nd) = sumd(nd) + 2*x(i)*xd(nd, i)
          ENDDO
          sum = sum + x(i)**2
        ENDDO
        DO nd=1,nbdirs
          IF (sum .EQ. 0.0) THEN
            x1d(nd) = 0.0
          ELSE
            x1d(nd) = sumd(nd)/(2.0*SQRT(sum))
          END IF
        ENDDO
        x1 = SQRT(sum)
        y1 = FLOAT(n)
        IF (x1 .LT. y1) THEN
          max1 = y1
          DO nd=1,nbdirs
            max1d(nd) = 0.0
          ENDDO
        ELSE
          DO nd=1,nbdirs
            max1d(nd) = x1d(nd)
          ENDDO
          max1 = x1
        END IF
        DO nd=1,nbdirs
          stpmaxd(nd) = stpmx*max1d(nd)
        ENDDO
        stpmax = stpmx*max1
        DO nd=1,nbdirs
          DO ii1=1,n_vapor
            gd(nd, ii1) = 0.0
          ENDDO
          DO ii1=1,n_vapor
            pd(nd, ii1) = 0.0
          ENDDO
          DO ii1=1,n_vapor
            xoldd(nd, ii1) = 0.0
          ENDDO
          DO ii1=1,n_vapor
            DO ii2=1,n_vapor
              fjacd(nd, ii2, ii1) = 0.0
            ENDDO
          ENDDO
        ENDDO
C start of iteration loop
        DO its=1,maxits
          CALL FDJAC_DV(n, x, xd, fjac, fjacd, nbdirs)
C get Jacobian
C compute Delta f for line search
          DO i=1,n
            sum = 0.0
            DO nd=1,nbdirs
              sumd(nd) = 0.0
            ENDDO
            DO j=1,n
              DO nd=1,nbdirs
                sumd(nd) = sumd(nd) + fvec(j)*fjacd(nd, j, i)
              ENDDO
              sum = sum + fjac(j, i)*fvec(j)
            ENDDO
            DO nd=1,nbdirs
              gd(nd, i) = sumd(nd)
            ENDDO
            g(i) = sum
          ENDDO
C store X
          DO i=1,n
            DO nd=1,nbdirs
              xoldd(nd, i) = xd(nd, i)
            ENDDO
            xold(i) = x(i)
          ENDDO
          DO nd=1,nbdirs
            foldd(nd) = fd(nd)
          ENDDO
C store F
          fold = f
C right-hand side for linear equations
          DO i=1,n
            DO nd=1,nbdirs
              pd(nd, i) = 0.0
            ENDDO
            p(i) = -fvec(i)
          ENDDO
          CALL LUDCMP_DV(fjac, fjacd, n, indx, d, nbdirs)
C solve linear equations by LU decomposition
          CALL LUBKSB_DV(fjac, fjacd, n, indx, p, pd, nbdirs)
C LNSRCH returns new X and F. It also
C calculates FVEC at the new X when it
          CALL LNSRCH_DV(ctot, ctotd, n, xold, xoldd, fold, foldd, g, gd
     +                   , p, pd, x, xd, f, fd, stpmax, stpmaxd, tolx,
     +                   check, nbdirs)
C calls FMINV
          test = 0.0
          DO i=1,n
            IF (fvec(i) .GE. 0.) THEN
              abs1 = fvec(i)
            ELSE
              abs1 = -fvec(i)
            END IF
            IF (abs1 .GT. test) THEN
              IF (fvec(i) .GE. 0.) THEN
                test = fvec(i)
              ELSE
                test = -fvec(i)
              END IF
            END IF
          ENDDO
          IF (test .LT. tolf) THEN
            GOTO 100
          ELSE IF (check) THEN
            GOTO 110
          ELSE
CTest for convergence on delta_x
            test = 0.0
            DO i=1,n
              IF (x(i) - xold(i) .GE. 0.) THEN
                abs2 = x(i) - xold(i)
              ELSE
                abs2 = -(x(i)-xold(i))
              END IF
              IF (x(i) .GE. 0.) THEN
                x2 = x(i)
              ELSE
                x2 = -x(i)
              END IF
              IF (x2 .LT. 1.0) THEN
                max2 = 1.0
              ELSE
                max2 = x2
              END IF
              temp = abs2/max2
              IF (temp .GT. test) test = temp
            ENDDO
            IF (test .LT. tolx) GOTO 120
          END IF
        ENDDO
        WRITE(*, '(a,i2)') 'MAXITS exceeded in NEWT ! Layer: ', layer
        GOTO 130
 100    check = .false.
        RETURN
CCheck for gradient of F zero,
Ci.e., spurious convergence.
 110    test = 0.
        IF (f .LT. 0.5*n) THEN
          den = 0.5*n
        ELSE
          den = f
        END IF
        DO i=1,n
          IF (g(i) .GE. 0.) THEN
            abs3 = g(i)
          ELSE
            abs3 = -g(i)
          END IF
          IF (x(i) .GE. 0.) THEN
            x3 = x(i)
          ELSE
            x3 = -x(i)
          END IF
          IF (x3 .LT. 1.0) THEN
            max3 = 1.0
          ELSE
            max3 = x3
          END IF
          temp = abs3*max3/den
          IF (temp .GT. test) test = temp
        ENDDO
        IF (test .LT. tolmin) THEN
          check = .true.
        ELSE
          check = .false.
        END IF
        RETURN
 120    RETURN
      END IF
 130  CONTINUE

      Return
      End Subroutine NEWT_DV

C-----------------------------------------------------------------------

C  Differentiation of fdjac in forward (tangent) mode:
C   variations   of useful results: fjac
C   with respect to varying inputs: m x fjac
C
      SUBROUTINE FDJAC_DV(n, x, xd, fjac, fjacd, nbdirs)
      IMPLICIT NONE
C dimension of problem
      INTEGER n
C initial guess of CAER
      REAL( 4 ) x(n)
      REAL( 8 ) xd(nbdirsmax, n)
C
      REAL( 8 ) ct
      REAL( 8 ) cs
      REAL( 8 ) imw
      REAL( 8 ) m
      REAL( 8 ) md(nbdirsmax)
      COMMON /newtinp/ ct(n_vapor), cs(n_vapor), imw(n_vapor), m
C
      REAL( 8 ) fjac(n, n)
      REAL( 8 ) fjacd(nbdirsmax, n, n)
C
C loop index
      INTEGER i, j
      REAL( 8 ) a(n_vapor)
      REAL( 8 ) b(n_vapor)
      REAL( 8 ) b1
      REAL( 8 ) b1d(nbdirsmax)
      REAL( 8 ) b2
      REAL( 8 ) b2d(nbdirsmax)
      REAL( 8 ) sum_jnei
      REAL( 8 ) sum_jneid(nbdirsmax)
      INTEGER nd
      INTEGER nbdirs
      REAL( 8 ) bd(nbdirsmax, n_vapor)
      INTEGER ii1
      REAL( 8 ) ad(nbdirsmax, n_vapor)
      COMMON /newtinp_dv/ md
      DO nd=1,nbdirs
        DO ii1=1,n_vapor
          bd(nd, ii1) = 0.0
        ENDDO
      ENDDO
C
      DO i=1,n
        DO nd=1,nbdirs
          ad(nd, i) = 0.0
        ENDDO
        a(i) = imw(i)
        sum_jnei = 0.0
        DO nd=1,nbdirs
          sum_jneid(nd) = 0.0
        ENDDO
        DO j=1,n
          DO nd=1,nbdirs
            sum_jneid(nd) = sum_jneid(nd) + imw(j)*xd(nd, j)
          ENDDO
          sum_jnei = sum_jnei + x(j)*imw(j)
        ENDDO
        DO nd=1,nbdirs
          b1d(nd) = sum_jneid(nd) - imw(i)*xd(nd, i)
          b2d(nd) = md(nd)
          bd(nd, i) = b1d(nd) + b2d(nd)
        ENDDO
        b1 = sum_jnei - x(i)*imw(i)
        b2 = (cs(i)-ct(i))*imw(i) + m
        b(i) = b1 + b2
      ENDDO
      DO j=1,n
        DO i=1,n
          IF (i .EQ. j) THEN
            DO nd=1,nbdirs
              fjacd(nd, i, j) = 2.0*a(i)*xd(nd, i) + bd(nd, i)
            ENDDO
            fjac(i, j) = 2.0*a(i)*x(i) + b(i)
          ELSE
            DO nd=1,nbdirs
              fjacd(nd, i, j) = imw(j)*xd(nd, i)
            ENDDO
            fjac(i, j) = (x(i)-ct(i))*imw(j)
          END IF
        ENDDO
      ENDDO
C
      RETURN
      END SUBROUTINE FDJAC_DV

C-----------------------------------------------------------------------

C  Differentiation of lnsrch in forward (tangent) mode:
C   variations   of useful results: f p x
C   with respect to varying inputs: fold g p x xold ctot stpmax
C                /newtinp/[0,4[
C
C-----------------------------------------------------------------------
      SUBROUTINE LNSRCH_DV(ctot, ctotd, n, xold, xoldd, fold, foldd, g,
     +                     gd, p, pd, x, xd, f, fd, stpmax, stpmaxd,
     +                     tolx, check, nbdirs)
      IMPLICIT NONE
C
      INTEGER n
      REAL( 8 ) tolx
      LOGICAL check
      REAL( 8 ) f
      REAL( 8 ) fold, stpmax
      REAL( 8 ) fd(nbdirsmax), foldd(nbdirsmax), stpmaxd(nbdirsmax)
      REAL( 4 ) x(n)
      REAL( 8 ) g(n), p(n), xold(n)
      REAL( 8 ) gd(nbdirsmax, n), pd(nbdirsmax, n), xd(nbdirsmax, n), xoldd(
     +     nbdirsmax, n)
      REAL( 4 ) ctot(n)
      REAL( 8 ) ctotd(nbdirsmax, n)
      REAL( 8 ), PARAMETER :: alf=1.e-04
      REAL( 8 ), PARAMETER :: conmin=1.e-30
C
      INTEGER i
      REAL( 8 ) a, alam, alam2, alamin, b, disc
      REAL( 8 ) ad(nbdirsmax), alamd(nbdirsmax), alam2d(nbdirsmax), bd(
     +     nbdirsmax), discd(nbdirsmax)
      REAL( 8 ) f2, fold2, rhs1, rhs2, slope
      REAL( 8 ) f2d(nbdirsmax), fold2d(nbdirsmax), rhs1d(nbdirsmax), rhs2d(
     +     nbdirsmax), sloped(nbdirsmax)
      REAL( 8 ) sum, temp, test, tmplam
      REAL( 8 ) sumd(nbdirsmax), tmplamd(nbdirsmax)
      REAL( 8 ) result1
      REAL( 8 ) result1d(nbdirsmax)
      INTEGER nd
      INTEGER nbdirs
      INTRINSIC MAX
      INTRINSIC ABS
      REAL( 8 ) x1
      REAL( 8 ) abs0
      INTRINSIC SQRT
      REAL( 8 ) max1
C
      check = .false.
      sum = 0.0
      DO nd=1,nbdirs
        sumd(nd) = 0.0
      ENDDO
      DO i=1,n
        DO nd=1,nbdirs
          sumd(nd) = sumd(nd) + pd(nd, i)*p(i) + p(i)*pd(nd, i)
        ENDDO
        sum = sum + p(i)*p(i)
      ENDDO
      DO nd=1,nbdirs
        IF (sum .EQ. 0.0) THEN
          sumd(nd) = 0.0
        ELSE
          sumd(nd) = sumd(nd)/(2.0*SQRT(sum))
        END IF
      ENDDO
      sum = SQRT(sum)
      IF (sum .GT. stpmax) THEN
        DO i=1,n
          DO nd=1,nbdirs
            pd(nd, i) = ((pd(nd, i)*stpmax+p(i)*stpmaxd(nd))*sum-p(i)*
     +        stpmax*sumd(nd))/sum**2
          ENDDO
          p(i) = p(i)*stpmax/sum
        ENDDO
      END IF
      slope = 0.0
      DO nd=1,nbdirs
        sloped(nd) = 0.0
      ENDDO
      DO i=1,n
        DO nd=1,nbdirs
          sloped(nd) = sloped(nd) + gd(nd, i)*p(i) + g(i)*pd(nd, i)
        ENDDO
        slope = slope + g(i)*p(i)
      ENDDO
      test = 0.0
      DO i=1,n
        IF (p(i) .GE. 0.) THEN
          abs0 = p(i)
        ELSE
          abs0 = -p(i)
        END IF
        IF (xold(i) .GE. 0.) THEN
          x1 = xold(i)
        ELSE
          x1 = -xold(i)
        END IF
        IF (x1 .LT. 1.0) THEN
          max1 = 1.0
        ELSE
          max1 = x1
        END IF
        temp = abs0/max1
        IF (temp .GT. test) test = temp
      ENDDO
      alamin = tolx/test
      alam = 1.0
      DO nd=1,nbdirs
        alam2d(nd) = 0.0
        f2d(nd) = 0.0
        alamd(nd) = 0.0
        fold2d(nd) = 0.0
      ENDDO
 101  CONTINUE
C
C
C  avoid negative concentrations and set upper limit given by CTOT.
C
      DO i=1,n
        DO nd=1,nbdirs
          xd(nd, i) = xoldd(nd, i) + alamd(nd)*p(i) + alam*pd(nd, i)
        ENDDO
        x(i) = xold(i) + alam*p(i)
        IF (x(i) .LE. 0.0) THEN
          DO nd=1,nbdirs
            xd(nd, i) = 0.0
          ENDDO
          x(i) = conmin
        END IF
        IF (x(i) .GT. ctot(i)) THEN
          DO nd=1,nbdirs
            xd(nd, i) = ctotd(nd, i)
          ENDDO
          x(i) = ctot(i)
        END IF
      ENDDO
      CALL FMINV_DV(x, xd, f, fd, nbdirs)
      IF (alam .GE. alamin) THEN
        IF (f .LE. fold + alf*alam*slope) THEN
          GOTO 100
        ELSE
          IF (alam .EQ. 1.0) THEN
            DO nd=1,nbdirs
              tmplamd(nd) = -((sloped(nd)*2.0*(f-fold-slope)-slope*2.0*(
     +          fd(nd)-foldd(nd)-sloped(nd)))/(2.0*(f-fold-slope))**2)
            ENDDO
            tmplam = -(slope/(2.0*(f-fold-slope)))
          ELSE
            rhs1 = f - fold - alam*slope
            rhs2 = f2 - fold2 - alam2*slope
            DO nd=1,nbdirs
              rhs1d(nd) = fd(nd) - foldd(nd) - alamd(nd)*slope - alam*
     +          sloped(nd)
              rhs2d(nd) = f2d(nd) - fold2d(nd) - alam2d(nd)*slope -
     +          alam2*sloped(nd)
              ad(nd) = (((rhs1d(nd)*alam**2-rhs1*2*alam*alamd(nd))/(alam
     +          **2)**2-(rhs2d(nd)*alam2**2-rhs2*2*alam2*alam2d(nd))/(
     +          alam2**2)**2)*(alam-alam2)-(rhs1/alam**2-rhs2/alam2**2)*
     +          (alamd(nd)-alam2d(nd)))/(alam-alam2)**2
              bd(nd) = ((((alamd(nd)*rhs2+alam*rhs2d(nd))*alam2**2-alam*
     +          rhs2*2*alam2*alam2d(nd))/(alam2**2)**2-((alam2d(nd)*rhs1
     +          +alam2*rhs1d(nd))*alam**2-alam2*rhs1*2*alam*alamd(nd))/(
     +          alam**2)**2)*(alam-alam2)-(-(alam2*rhs1/alam**2)+alam*
     +          rhs2/alam2**2)*(alamd(nd)-alam2d(nd)))/(alam-alam2)**2
            ENDDO
            a = (rhs1/alam**2-rhs2/alam2**2)/(alam-alam2)
            b = (-(alam2*rhs1/alam**2)+alam*rhs2/alam2**2)/(alam-alam2)
            IF (a .EQ. 0.0) THEN
              DO nd=1,nbdirs
                tmplamd(nd) = -((sloped(nd)*2.0*b-slope*2.0*bd(nd))/(2.0
     +            *b)**2)
              ENDDO
              tmplam = -(slope/(2.0*b))
            ELSE
              disc = b*b - 3.0*a*slope
              result1 = SQRT(disc)
              DO nd=1,nbdirs
                discd(nd) = bd(nd)*b + b*bd(nd) - 3.0*(ad(nd)*slope+a*
     +            sloped(nd))
                IF (disc .EQ. 0.0) THEN
                  result1d(nd) = 0.0
                ELSE
                  result1d(nd) = discd(nd)/(2.0*SQRT(disc))
                END IF
                tmplamd(nd) = ((result1d(nd)-bd(nd))*3.0*a-(-b+result1)*
     +            3.0*ad(nd))/(3.0*a)**2
              ENDDO
              tmplam = (-b+result1)/(3.0*a)
            END IF
            IF (tmplam .GT. 0.5*alam) THEN
              DO nd=1,nbdirs
                tmplamd(nd) = 0.5*alamd(nd)
              ENDDO
              tmplam = 0.5*alam
            END IF
          END IF
          DO nd=1,nbdirs
            alam2d(nd) = alamd(nd)
            f2d(nd) = fd(nd)
            fold2d(nd) = foldd(nd)
          ENDDO
          alam2 = alam
          f2 = f
          fold2 = fold
          IF (tmplam .LT. 0.1*alam) THEN
            DO nd=1,nbdirs
              alamd(nd) = 0.1*alamd(nd)
            ENDDO
            alam = 0.1*alam
          ELSE
            DO nd=1,nbdirs
              alamd(nd) = tmplamd(nd)
            ENDDO
            alam = tmplam
          END IF
          GOTO 101
        END IF
      END IF
      DO i=1,n
        DO nd=1,nbdirs
          xd(nd, i) = xoldd(nd, i)
        ENDDO
        x(i) = xold(i)
      ENDDO
      check = .true.
      RETURN
 100  RETURN
      END SUBROUTINE LNSRCH_DV

C-----------------------------------------------------------------------

C  Differentiation of fminv in forward (tangent) mode:
C   variations   of useful results: f
C   with respect to varying inputs: x /newtinp/[0,4[
C
C-----------------------------------------------------------------------
      SUBROUTINE FMINV_DV(x, xd, f, fd, nbdirs)
      IMPLICIT NONE
      INTEGER n
C
      REAL( 4 ) x(*)
      REAL( 8 ) f
      REAL( 8 ) xd(nbdirsmax, *), fd(nbdirsmax)
      REAL( 8 ) fvec
      REAL( 8 ) fvecd(nbdirsmax, n_vapor)
C
      COMMON /newtv/ fvec(n_vapor), n
      SAVE /newtv/
C
      INTEGER i
      REAL( 8 ) sum
      REAL( 8 ) sumd(nbdirsmax)
      INTEGER nd
      INTEGER nbdirs
      CALL FUNCV_DV(n, x, xd, fvec, fvecd, nbdirs)
      sum = 0.0
      DO nd=1,nbdirs
        sumd(nd) = 0.0
      ENDDO
      DO i=1,n
        DO nd=1,nbdirs
          sumd(nd) = sumd(nd) + 2*fvec(i)*fvecd(nd, i)
        ENDDO
        sum = sum + fvec(i)**2
      ENDDO
      DO nd=1,nbdirs
        fd(nd) = 0.5*sumd(nd)
      ENDDO
      f = 0.5*sum
      RETURN
      END SUBROUTINE FMINV_DV

C-----------------------------------------------------------------------

C  Differentiation of funcv in forward (tangent) mode:
C   variations   of useful results: fvec
C   with respect to varying inputs: m x
C
C-----------------------------------------------------------------------
      SUBROUTINE FUNCV_DV(n, x, xd, fvec, fvecd, nbdirs)
      IMPLICIT NONE
C
      INTEGER n
      REAL( 4 ) x(*)
      REAL( 8 ) xd(nbdirsmax, *)
      REAL( 8 ) fvec(n)
      REAL( 8 ) fvecd(nbdirsmax, n)
C
      REAL( 8 ) ct
      REAL( 8 ) cs
      REAL( 8 ) imw
      REAL( 8 ) m
      REAL( 8 ) md(nbdirsmax)
      COMMON /newtinp/ ct(n_vapor), cs(n_vapor), imw(n_vapor), m
      SAVE /newtinp/
C
      INTEGER i, j
      REAL( 8 ) sum_jnei
      REAL( 8 ) sum_jneid(nbdirsmax)
      REAL( 8 ) a(n_vapor)
      REAL( 8 ) b(n_vapor)
      REAL( 8 ) c(n_vapor)
      INTEGER nd
      INTEGER nbdirs
      REAL( 8 ) cd(nbdirsmax, n_vapor)
      REAL( 8 ) bd(nbdirsmax, n_vapor)
      INTEGER ii1
      REAL( 8 ) ad(nbdirsmax, n_vapor)
      COMMON /newtinp_dv/ md
      DO nd=1,nbdirs
        DO ii1=1,n
          fvecd(nd, ii1) = 0.0
        ENDDO
        DO ii1=1,n_vapor
          bd(nd, ii1) = 0.0
        ENDDO
        DO ii1=1,n_vapor
          cd(nd, ii1) = 0.0
        ENDDO
      ENDDO
C
      DO i=1,n
        DO nd=1,nbdirs
          ad(nd, i) = 0.0
        ENDDO
        a(i) = imw(i)
        sum_jnei = 0.0
        DO nd=1,nbdirs
          sum_jneid(nd) = 0.0
        ENDDO
        DO j=1,n
          DO nd=1,nbdirs
            sum_jneid(nd) = sum_jneid(nd) + imw(j)*xd(nd, j)
          ENDDO
          sum_jnei = sum_jnei + x(j)*imw(j)
        ENDDO
        sum_jnei = sum_jnei - x(i)*imw(i)
        b(i) = sum_jnei + m + (cs(i)-ct(i))*imw(i)
        DO nd=1,nbdirs
          sum_jneid(nd) = sum_jneid(nd) - imw(i)*xd(nd, i)
          bd(nd, i) = sum_jneid(nd) + md(nd)
          cd(nd, i) = -(ct(i)*(sum_jneid(nd)+md(nd)))
          fvecd(nd, i) = xd(nd, i)*(a(i)*x(i)+b(i)) + x(i)*(a(i)*xd(nd,
     +      i)+bd(nd, i)) + cd(nd, i)
        ENDDO
        c(i) = -(ct(i)*(sum_jnei+m))
        fvec(i) = x(i)*(a(i)*x(i)+b(i)) + c(i)
      ENDDO
C
      RETURN
      END SUBROUTINE FUNCV_DV

C-----------------------------------------------------------------------

C  Differentiation of lubksb in forward (tangent) mode:
C   variations   of useful results: b
C   with respect to varying inputs: a b
C
C-----------------------------------------------------------------------
      SUBROUTINE LUBKSB_DV(a, ad, n, indx, b, bd, nbdirs)
      IMPLICIT NONE
C
      INTEGER n, indx(n)
C A now has dimension NxN.
      REAL( 8 ) a(n, n), b(n)
      REAL( 8 ) ad(nbdirsmax, n, n), bd(nbdirsmax, n)
C
      INTEGER i, ii, j, ll
      REAL( 8 ) sum
      REAL( 8 ) sumd(nbdirsmax)
      INTEGER nd
      INTEGER nbdirs
C
      ii = 0
      DO i=1,n
        ll = indx(i)
        DO nd=1,nbdirs
          sumd(nd) = bd(nd, ll)
          bd(nd, ll) = bd(nd, i)
        ENDDO
        sum = b(ll)
        b(ll) = b(i)
        IF (ii .NE. 0) THEN
          DO j=ii,i-1
            DO nd=1,nbdirs
              sumd(nd) = sumd(nd) - ad(nd, i, j)*b(j) - a(i, j)*bd(nd, j
     +          )
            ENDDO
            sum = sum - a(i, j)*b(j)
          ENDDO
        ELSE IF (sum .NE. 0) THEN
          ii = i
        END IF
        DO nd=1,nbdirs
          bd(nd, i) = sumd(nd)
        ENDDO
        b(i) = sum
      ENDDO
      DO i=n,1,-1
        DO nd=1,nbdirs
          sumd(nd) = bd(nd, i)
        ENDDO
        sum = b(i)
        DO j=i+1,n
          DO nd=1,nbdirs
            sumd(nd) = sumd(nd) - ad(nd, i, j)*b(j) - a(i, j)*bd(nd, j)
          ENDDO
          sum = sum - a(i, j)*b(j)
        ENDDO
        DO nd=1,nbdirs
          bd(nd, i) = (sumd(nd)*a(i, i)-sum*ad(nd, i, i))/a(i, i)**2
        ENDDO
        b(i) = sum/a(i, i)
      ENDDO
C
      RETURN
      END SUBROUTINE LUBKSB_DV

C-----------------------------------------------------------------------

C  Differentiation of ludcmp in forward (tangent) mode:
C   variations   of useful results: a
C   with respect to varying inputs: a
C
C-----------------------------------------------------------------------
      SUBROUTINE LUDCMP_DV(a, ad, n, indx, d, nbdirs)
      IMPLICIT NONE

      INTEGER n, indx(n)
C     INTEGER NMAX
C     PARAMETER ( NMAX = 10 )   ! largest expected N
C note that A now has dimension NxN
C NCVAP is ignored
      REAL( 8 ) d, a(n, n)
      REAL( 8 ) ad(nbdirsmax, n, n)
      REAL( 8 ), PARAMETER :: tiny=1.0e-20
C
      INTEGER i, imax, j, k
      REAL( 8 ) aamax, dum, sum, vv(n)
      REAL( 8 ) dumd(nbdirsmax), sumd(nbdirsmax)
      INTEGER nd
      INTEGER nbdirs
      INTRINSIC ABS
      REAL( 8 ) abs1
      REAL( 8 ) abs0
C
      d = 1
      DO i=1,n
        aamax = 0.0
        DO j=1,n
          IF (a(i, j) .GE. 0.) THEN
            abs0 = a(i, j)
          ELSE
            abs0 = -a(i, j)
          END IF
          IF (abs0 .GT. aamax) THEN
            IF (a(i, j) .GE. 0.) THEN
              aamax = a(i, j)
            ELSE
              aamax = -a(i, j)
            END IF
          END IF
        ENDDO
        IF (aamax .EQ. 0.0) WRITE(*, '(a)')
     +                            '*** Singular matrix in ludcmp!'
C           STOP
        vv(i) = 1.0/aamax
      ENDDO
      DO j=1,n
        DO i=1,j-1
          DO nd=1,nbdirs
            sumd(nd) = ad(nd, i, j)
          ENDDO
          sum = a(i, j)
          DO k=1,i-1
            DO nd=1,nbdirs
              sumd(nd) = sumd(nd) - ad(nd, i, k)*a(k, j) - a(i, k)*ad(nd
     +          , k, j)
            ENDDO
            sum = sum - a(i, k)*a(k, j)
          ENDDO
          DO nd=1,nbdirs
            ad(nd, i, j) = sumd(nd)
          ENDDO
          a(i, j) = sum
        ENDDO
        aamax = 0.0
        DO i=j,n
          DO nd=1,nbdirs
            sumd(nd) = ad(nd, i, j)
          ENDDO
          sum = a(i, j)
          DO k=1,j-1
            DO nd=1,nbdirs
              sumd(nd) = sumd(nd) - ad(nd, i, k)*a(k, j) - a(i, k)*ad(nd
     +          , k, j)
            ENDDO
            sum = sum - a(i, k)*a(k, j)
          ENDDO
          DO nd=1,nbdirs
            ad(nd, i, j) = sumd(nd)
          ENDDO
          a(i, j) = sum
          IF (sum .GE. 0.) THEN
            abs1 = sum
          ELSE
            abs1 = -sum
          END IF
          dum = vv(i)*abs1
          IF (dum .GE. aamax) THEN
            imax = i
            aamax = dum
          END IF
        ENDDO
        IF (j .NE. imax) THEN
          DO k=1,n
            DO nd=1,nbdirs
              dumd(nd) = ad(nd, imax, k)
              ad(nd, imax, k) = ad(nd, j, k)
              ad(nd, j, k) = dumd(nd)
            ENDDO
            dum = a(imax, k)
            a(imax, k) = a(j, k)
            a(j, k) = dum
          ENDDO
          d = -d
          vv(imax) = vv(j)
        END IF
        indx(j) = imax
        IF (a(j, j) .EQ. 0.0) THEN
          DO nd=1,nbdirs
            ad(nd, j, j) = 0.0
          ENDDO
          a(j, j) = tiny
        END IF
        IF (j .NE. n) THEN
          DO nd=1,nbdirs
            dumd(nd) = -(ad(nd, j, j)/a(j, j)**2)
          ENDDO
          dum = 1.0/a(j, j)
          DO i=j+1,n
            DO nd=1,nbdirs
              ad(nd, i, j) = ad(nd, i, j)*dum + a(i, j)*dumd(nd)
            ENDDO
            a(i, j) = a(i, j)*dum
          ENDDO
        END IF
      ENDDO
C
      RETURN
      END SUBROUTINE LUDCMP_DV
C


C-----------------------------------------------------------------------

      End Module aero6_ddm3d



